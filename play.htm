<html>
    <head>
        <title>Another Pattern for Almost Compositional Functions</title>
        <style type="text/css">
pre {
    border: 2px solid gray;
    padding: 1px;
    padding-left: 5px;
    margin-left: 10px;
    background-color: #eee;
}

pre.define {
    background-color: #ffb;
    border-color: #cc0;
}

pre.compos, pre.syb {
    font-style: italic;
}

body {
    font-family: sans-serif;
}

h1, h2, h3 {
    font-family: serif;
}

h1 {
    color: rgb(23,54,93);
    border-bottom: 1px solid rgb(79,129,189);
    padding-bottom: 2px;
    font-variant: small-caps;
    text-align: center;
}

a {
    color: rgb(54,95,145);
}

h2 {
    color: rgb(54,95,145);
}

h3 {
    color: rgb(79,129,189);
}
        </style>
    </head>
    <body>

<h1>Another Pattern for Almost Compositional Functions</h1>

<p style="text-align:right;margin-bottom:25px;">
	by <a href="http://www.cs.york.ac.uk/~ndm/">Neil Mitchell</a>
</p>

<p>
    In ICFP 2006 Bj&ouml;rn Bringert and Aarne Ranta introduced their paper, <a href="http://doi.acm.org/10.1145/1159803.1159834">"A Pattern for Almost Compositional Functions"</a> - which I refer to as Compos (after the name of their class). In the year preceding this I had developed a different pattern, which I call the <i>Play</i> class. This pattern had been implemented in Yhc for the Core data type, and in Catch on several data types within the program. An undergrad pointed me at the above paper, and it was easy to see the similarities between the intentions. Since I feel my Play class offers some advantages (and some disadvantages, naturally) over the published approach, it seems sensible to turn my pattern into a library and provide some documentation to cover it.
</p>
<p>
</p>
    This document proceeds as follows:
<p>
</p>
<ol>
    <li>The motivation and use cases for Play</li>
    <li>How to use the Play class</li>
    <li>Derivation of a Play instance for your own data type</li>
    <li>Extension to PlayEx</li>
    <li>A comparison to the Compos paper</li>
</ol>
<p>
    All the examples used in this document can be found in the darcs repository, under the <tt>Examples</tt> directory.
</p>
<pre>
darcs get --partial <a href="http://www.cs.york.ac.uk/fp/darcs/play">http://www.cs.york.ac.uk/fp/darcs/play</a>
</pre>

<h3>Acknowledgements</h3>

<p>
	Thanks to Bj&ouml;rn Bringert for feedback on an earlier version of this document, and to Matt Naylor and Tom Shackell for helpful discussions.
</p>


<h2>Motivation and Use Cases</h2>

<p>
    The idea behind the Play class is that there exists a data structure, usually with a reasonable number of constructors, which is often transformed or analysed. The usual example of this would be a compiler, which has at its core an expression type. This can be seen as a form of generic programming.
</p>
<p>
    The Play class has the following goals:
</p>
<ul>
    <li>Adding a new constructor should require very few changes</li>
    <li>Traversals should have a minimal amount of boiler plate</li>
    <li>The obvious code should "just work"</li>
    <li>Haskell 98, where possible</li>
    <li>Writing new types of traverals is easy</li>
    <li>The default traversals cover most cases</li>
</ul>
<p>
    The ideas behind the Play class have been used extensively, in both the Yhc compiler and the Catch tool. In Catch there are 109 traversals using the Play class (as at Nov 2006), showing that the Play class gets extensive use.
</p>


<h2>Using Play</h2>

<p>
    These examples revolve around a small arithmetic language, given here:

</p>
<pre>
import Data.Play

data Expr = Val Int
          | Add Expr Expr
          | Sub Expr Expr
          | Div Expr Expr
          | Mul Expr Expr
          | Neg Expr
          deriving (Show, Eq)
</pre>
<p>
    Assume that a Play class has already been written; so now <tt>instance Play Expr</tt> is available to us. Some examples are presented, in rough order of increasingly complexity. These examples are all available in the <tt>Examples/Expr.hs</tt> file.
</p>

<h3>Checking for division by zero</h3>

<pre class="define">
allOver :: Play on => on -> [on]
</pre>
<p>
    If an expression is divided by zero, this causes a runtime error in our language. As part of the compiler, it's nice to give the user a warning message about this. This can be done with the following test:
</p>
<pre>
hasDivZero :: Expr -> Bool
hasDivZero x = not $ null [() | Div _ (Val 0) <- allOver x]
</pre>
<p>
    Here the only Play method being used is <tt>allOver</tt>. Given a tree, <tt>allOver</tt> returns all the root of the tree, and all it's subtrees at all levels. This can be used to quickly flatten a tree structure into a list, for quick analysis via list comprehensions, as is done above. For each division by zero found, any value is created in the list comprehension, and then this is checked to see if anything did match. Returning the count of divide by zero errors is trivial, simply use <tt>length</tt> instead of <tt>not $ null</tt>.  Extra context could perhaps be given by printing some of the value that is being divided by zero, to help narrow down the error.
</p>
<p>
    <i>Exercise:</i> Write a function to find all literals that occur in an expression, together with their count.
</p>

<h3>Basic optimisation</h3>

<pre class="define">
mapUnder :: Play on => (on -> on) -> on -> on
</pre>
<p>
    If we are negating a literal value, this computation can be performed in advance, so let's write a function to do this.
</p>
<pre>
optimise :: Expr -> Expr
optimise = mapUnder $ \x -> case x of
    Neg (Val i) -> Val (negate i)
    x -> x
</pre>
<p>
    Here the Play method being used is <tt>mapUnder</tt>. This applies the given function to all the children of an expression, before applying it to the parent. This can be thought of as bottom-up traversal of the data structure. There is an equivalent <tt>mapOver</tt> defined, but generally <tt>mapUnder</tt> is used about 90% of the time. The optimise code merely pattern matches on the negation of a literal, and replaces it with the literal. Using mapUnder means that <tt>Neg (Neg (Val 1))</tt> is reduced to <tt>1</tt>, using mapOver would only perform the inner most reduction.

</p>
<p>
    Now lets add another optimisation into the same pass, just before the <tt>x -> x</tt> line insert:
</p>
<pre>
    Add x y | x == y -> Mul x (Val 2)
</pre>
<p>
    This takes an addition where two terms are equal and changes it into a multiplication, causing the nested expression to be executed only once. This shows that normal Haskell applies, the Play lets you write code as before.
</p>
<p>
    <i>Exercise:</i> Extend the optimisation to so that adding <tt>x</tt> to <tt>Mul x (Val 2)</tt> produces a multiplication by 3.
</p>


<h3>Elimination of Negation</h3>

<pre class="define">
mapOver :: Play on => (on -> on) -> on -> on
</pre>
<p>
    It is possible to eliminate negation entirely, and perhaps this would be a useful computation to perform:
<p>
<pre>
noNegate :: Expr -> Expr
noNegate = mapOver $ \x -> case x of
    Neg (Val i) -> Val (negate i)
    Neg (Neg x) -> x
    Neg (Sub a b) -> Sub b a
    Neg (Add a b) -> Add (Neg a) (Neg b)
    Neg (Div a b) -> Div (Neg a) b
    Neg (Mul a b) -> Mul (Neg a) b
    x -> x
</pre>
<p>
    This is an example where a bottom up traversal would not work, as information is being pushed from the top downwards. Note how each line states a mathematical property, which can be proved in isolation, and that the Play class handles the traverals.
</p>
<p>
    <i>Exercise:</i> Write a similar transformation to eliminate subtraction. These two transformations can be composed, to give a reduced expression language. Can any other expressions be eliminated?
</p>


<h3>Depth of an expression</h3>

<pre class="define">
fold :: Play on => ([res] -> tmp) -> (on -> tmp -> res) -> on -> res
</pre>
<p>
    Now lets imagine that programmers in your language are paid by the depth of expression they produce, so lets write a function that computes the maximum depth of an expression.
</p>
<pre>
depth :: Expr -> Int
depth = fold (foldr max 0) $ const (+1)
</pre>
<p>
    This function performs a fold over the data structure. The <tt>foldr max</tt> is being used as maximum, with a starting value of <tt>0</tt>. The next bit simply says that for each iteration, add one to the previous depth.  An evaluator for this expression language can also be modelled as a <tt>fold</tt>, see inside the example directory to see an implementation.
</p>
<p>
    Each <tt>fold</tt> collects all the values from the children of an expression, combines them using the first function, then generates a new value based on the expression. Often the combining function will simply be <tt>id</tt>.
<p>
<p>
    <i>Exercise:</i> Write a function that counts the maximum depth of addition only.
</p>

<h3>Renumbering literals</h3>

<pre class="define">
mapUnderM :: (Monad m, Play on) => (on -> m on) -> on -> m on
</pre>
<p>
    The literal values need to be replaced with a sequence of numbers, each unique. This is unlikely for an arithmetic expression, but consider bound variables in lambda calculus and it starts to become a bit more plausible:
</p>
<pre>
uniqueLits :: Expr -> Expr
uniqueLits x = evalState (mapUnderM f x) [0..]
    where
        f (Val i) = do
            y:ys <- get
            put ys
            return (Val y)
        f x = return x
</pre>
<p>
    Here a monadic computation is required, the program needs to keep track of what the next item in the list to use is, and replace the current item. By using the state monad, this can be done easily.
</p>
<p>
    <i>Exercise:</i> Allow each literal to occur only once, when a second occurance is detected, replace that literal with zero.
</p>

<h3>Reverse notation</h3>

<pre class="define">
replaceChildren :: Play on => on -> ([on], [on] -> on)
</pre>
<p>
    In general, <tt>allOver</tt> and <tt>mapUnder</tt> are used most of the time, and <tt>fold</tt> is used occasionally. The Play class is built upon the operation <tt>replaceChildren</tt>, which takes an expression, and returns a pair with the children of that expression, and a function to generate that expression with a new set of children in place. This operation can be directly exploited if required, although should be handled with caution.
</p>
<p>
    Let us make a function that reverses the order of all the inputs, say if the user is working in Right-to-Left mode on their computer:
</p>
<pre>
reverseExpr :: Expr -> Expr
reverseExpr = mapUnder f
    where
        f x = generate $ reverse collect
            where (collect,generate) = replaceChildren x
</pre>
<p>
    This expression does a standard <tt>mapUnder</tt>, but at each iteration calls <tt>replaceChildren</tt>, then reverses the children set before regenerating the original expression. This shows the underlying mechanism on which the library is based, and isn't recommended for average users.
</p>


<h2>Defining a Play instance</h2>

<p>
    As shown in the reversal example (just above), the only method in the Play class is <tt>replaceChildren</tt>. The Play class is defined as:
</p>
<pre class="define">
class Play on where
    replaceChildren :: on -> ([on], [on] -> on)
</pre>
<p>
    The idea is that given an item, you want to return all the children, and a function that will replace all the children. An invariant is that the list given to the second function will be the same length as that returned in the first element of the pair. Let's start by constructing the Play instance for the expression type.
</p>
<pre>
instance Play Expr of
    replaceChildren x =
        case x of
            Add a b -> ([a,b], \[a,b] -> Add a b)
            ...
            Neg a -> ([a], \[a] -> Neg a)
            Val i -> ([], \[] -> Val i)
</pre>
<p>
    A short study of the code should show how this works. The other constructors such as <tt>Mul</tt> follow the same pattern as <tt>Add</tt>. There are some additional combinators defined in the Play class to make this a bit easier.
</p>
<pre>
instance Play Expr of
    replaceChildren x =
        case x of
            Add x y -> playTwo Add x y
            ...
            Neg x   -> playOne Neg x
            x -> playDefault x
</pre>
<p>
    Here <tt>playTwo</tt> takes a constructor of two expressions, and the expressions within them. The function <tt>playOne</tt> operates similarly on one expression. The remaining <tt>playDefault</tt>, which handles <tt>Val</tt> is for expressions with no recursive element.
</p>


<h2>Using PlayEx</h2>

<p>
    The PlayEx class is not standard Haskell, requiring multi-parameter type classes. Where possible try and use the standard Play class. There are two mechanisms for writing <tt>PlayEx</tt> instances, one requires multi-parameter type classes, the other requires undecidable instances, but is a lot simpler.
</p>
<pre>
class Play with => PlayEx on with where
    replaceChildrenEx :: on -> ([with], [with] -> on)
</pre>
<p>
    The <tt>replaceChildrenEx</tt> method operates much like the <tt>replaceChildren</tt>, except it returns the list of elements which match first. When the two types are different this operations much like the original, but when <tt>on</tt> and <tt>with</tt> represent the same type, the result is just the single element list.
</p>

<h3>Using the operations from PlayEx</h3>

<p>
    To see various operations being used from the PlayEx class, take a look at <tt>Examples/ComposPaper.hs</tt>. Typically the operations are just the same as Play, with Ex on the end. To use the Ex methods either import Data.PlayMPTC or Data.PlaySYB - depending on how the instances are to be written.
</p>
<pre class="define">
mapUnderEx :: PlayEx on with => (with -> with) -> on -> on
mapUnderExM :: (Monad m, PlayEx on with) => (with -> m with) -> on -> m on
allOverEx :: PlayEx on with => on -> [with]
</pre>

<h3>Defining PlayEx manually</h3>

<p>
    To see an example of this style of definition, see <tt>Examples/ComposBasic.hs</tt>. Here the useful combinations for definitions are:
</p>
<pre class="define">
playExDefault :: (Play on, PlayEx on with) => on -> ([with], [with] -> on)
playSelf :: a -> ([a], [a] -> a)
playMore :: PlayEx a b => (a -> c) -> a -> ([b],[b] -> c)
</pre>
<p>
    The <tt>playSelf</tt> function simply operates on values of the same data type, so typically a defintion will be created such as:
</p>
<pre>
instance PlayEx Expr Expr where
    replaceChildrenEx = playSelf
</pre>
<p>
    The <tt>playExDefault</tt> takes on the same role as <tt>playDefault</tt> - when there are remaining definitions without any further interesting elements in. The <tt>playMore</tt> is designed to continue on the recursion, where elements on interest may lay within other elements.
</p>
<p>
    Defining a PlayEx class using these combinations and direct operations is quite hard, and quite error prone. It is not recommend unless there is no alternative due to implementation restrictions. Note however than even if a PlayEx class is defined with the more powerful tools, an equivalent requiring only MPTC's does exist, so your code is not tied to the extensions forever.
</p>

<h3>Using the PlayEx combinators</h3>

<p>
    To define the <tt>PlayEx</tt> class, there are three combinatiors that can be used. These automate much of the definition:
</p>
<pre class="define">
play :: on -> ([with],[with] -> on)
(/\) :: PlayEx item with => ([with], [with] -> item -> on) -> item -> ([with], [with] -> on)
(/\!) :: ([with], [with] -> item -> on) -> item -> ([with], [with] -> on)
</pre>
<p>
    Note, the above are presented with type signatures for completeness. They are intended to be used mechanically, without excessive thought.
</p>
<p>
    To define a PlayEx instance for the Expr type introduced earlier:
</p>
<pre>
instance PlayEx Expr a where
    replaceChildrenEx x =
        case x of
            Val a -> play Val /\! a
            Add a b -> play Add /\ a /\ b
            Sub a b -> play Sub /\ a /\ b
            ...
            Neg a -> play Neg /\ a
</pre>
<p>
    The definition follows mechanically. The only choice a user makes is whether to use the <tt>(/\)</tt> operator (which recurses into the child on the right), or the <tt>(/\!)</tt> operator, which doesn't. For example, here we have decided not to traverse inside the <tt>Int</tt> of <tt>Val</tt>. This can be changed, and would require a PlayEx instance for <tt>Int</tt>.
</p>
<p>
    If using this style of definition, a special instance must be defined for the self case:
</p>
<pre>
instance PlayEx Expr Expr where
    replaceChildrenEx = playSelf
</pre>
<p>
    Unfortunately this requires undecidable instances. A Play instance still needs to be written for each definition.
</p>

<h3>Using Scrap Your Boilerplate instances</h3>

<p>
    To define Play and PlayEx instances for all types, in all combinations, simply:
</p>
<pre>
import Data.PlaySYB

data Expr ... deriving (Typeable, Data)
</pre>
<p>
    The disadvatages of this are the lack of type safety - you can now do entirely meaningless operations, which the earlier definitions would have spotted as being an error. This code will also only work where <tt>Data.Generics</tt> is supported, namely GHC at the present time.
</p>
<p>
    The clear advantage is that there is almost no work to creating Play instances. While the SYB instances are more powerful, it is hoped that the Play instances are more intuative and match closer to the operations people perform on their code.
</p>


<h2>Comparison to the Compos Paper</h2>

<p>
    The Compos paper provides a similar mechansim, so the obvious question is how they related. A summary of the advantages and disadvantages is provided, followed by reimplementations of their operations using Play and PlayEx. This code can be found in the <tt>ComposPaper</tt> file. This section is designed to be read with a copy of the Compos paper to hand, alternatives are given, but the tasks are not explained in this section.
</p>
<p>
    Advantages of Play:
</p>
<ul>
    <li>Haskell 98 (the Play class), plus multi-parameter type classes (PlayEx only)</li>
    <li>Does not require GADT's or rank-2 types</li>
    <li>No need to change the data structure</li>
    <li>Less boilerplate in the traversal</li>
    <li>Supports more traversals</li>
</ul>
<p>
    Advantages of Compos:
</p>
<ul>
    <li>Easier to write traversal code</li>
    <li>Supports GADT's</li>
</ul>
<p>
    Now I compare the examples in the paper, with the equivalent using Play. The Compos variant is shown in <i>italics</i>.
</p>


<h3>Examples from Section 3</h3>

<p>
    First off, I replicate the data structure from their paper, along with a Play instance.
</p>
<pre>
data Exp = EAbs String Exp
         | EApp Exp Exp
         | EVar String
         deriving Show

instance Play Exp where
    replaceChildren x =
        case x of
            EAbs a c -> playOne (EAbs a) c
            EApp c1 c2 -> playTwo EApp c1 c2
            x -> playDefault x
</pre>

<h3>The <tt>rename</tt> function</h3>

<p>
    Now let us examine the <tt>rename</tt> function. In addition to the Compos and Play versions, I first present the version written <i>without</i> any traveral code:
</p>
<pre>
rename :: Exp -> Exp
rename e = case e of
    EAbs x b -> EAbs ("_" ++ x) (rename b)
    EApp c a -> EApp (rename c) (rename a)
    EVar x   -> EVar ("_" ++ x)
</pre>
<p>
    And now the two variants from the libraries:
</p>
<pre class="compos">
rename :: Exp -> Exp
rename e = case e of
    EAbs x b -> EAbs ("_" ++ x) (rename b)
    EVar x   -> EVar ("_" ++ x)
    _        -> composOp rename e
</pre>
<pre>
rename :: Exp -> Exp
rename = mapUnder $ \e -> case e of
    EAbs s x -> EAbs ("_" ++ s) x
    EVar s -> EVar ("_" ++ s)
    x -> x
</pre>
<p>
    Note that in the Compos version there is only one function, in contrast to two in the Play version. However, in the Play version the traversal code is at the top, whereas with Compos it is the base case. Also note that in <tt>EAbs</tt> Compos has to continue the recursion, if the <tt>(rename b)</tt> call was missed then this would not work - Play takes care of this detail automatically.
</p>


<h3>The <tt>free</tt> function</h3>

<pre class="compos">
free :: Exp -> [String]
free e = case e of
    EAbs x b -> delete x (free b)
    EVar x -> [x]
    _ -> composOpFold [] union free e
</pre>
<pre>
free :: Exp -> [String]
free = fold (nub . concat) $ \e y -> case e of
    EAbs s x -> delete s y
    EVar s -> [s]
    x -> y
</pre>
<p>
    In this function the two approaches are relatively similar, in Compos the fold information is at the bottom, in Play it is at the top. Play gives slightly more freedom by allowing the combining function to combine a list in the heirarchy at a time, while Compos only lets a merge function merge two elements.
</p>

<h3>The <tt>fresh</tt> function</h3>

<pre class="compos">
fresh :: Exp -> Exp
fresh x = evalState (f [] x) names
    where
        names = ["_" ++ show n | n <- [0..]]
        f vs t = case t of
            EAbs x b -> do
                y:fs <- get
                put fs
                liftM (EAbs y) (f ((x,y):vs) b)
            EVar x ->
                return (EVar (fromMaybe x (lookup x vs)))
            _ -> composOpM (f vs) t
</pre>
<pre>
fresh :: Exp -> Exp
fresh x = evalState (f [] x) names
    where
        names = ["_" ++ show n | n <- [0..]]
        f vs t = case t of
            EAbs x b -> do
                y:fs <- get
                put fs
                liftM (EAbs y) (f ((x,y):vs) b)
            EVar x ->
                return (EVar (fromMaybe x (lookup x vs)))
            _ -> composM (f vs) t
</pre>
<p>
    In this particular example, none of the built in traversals provided by Play are much better than Compos, so instead the <tt>compos</tt> operator has been defined in the Play framework. This shows that anything Compos can do, Play can copy at the very least. (The code from the Compos example has been updated to use <tt>Control.Monad.State</tt>, to make it more accessible)
</p>

<h3>Examples from Section 4</h3>

<p>
    The types manipulated by Secion 4 are:
</p>
<pre>
data Stm = SDecl Typ Var
         | SAss  Var Exp
         | SBlock [Stm]
         | SReturn Exp

data Exp = EStm Stm
         | EAdd Exp Exp
         | EVar Var
         | EInt Int

data Var = V String

data Typ = T_int | T_float
</pre>
<p>
    The first thing done by the Compos paper is to translate this into a GADT, which destroys abstraction. If a data structure representing a program was also defined, then this would have to be merged into the single GADT. Play on the other hand accepts the definition as supplied.
</p>
<p>
    The manual PlayEx instances for this data structure are not particularly nice, this is mainly due to the decision to have <tt>EStm</tt> in the <tt>Exp</tt> data type. A much more natural definition would be either to merge <tt>Stm</tt> and <tt>Exp</tt>, or to add <tt>SExp</tt> to <tt>Stm</tt>. If either of these things were done, then the Play instances would be vastly simplified. Because of the ugliness of the manual Play instances, I merely list the instances defined, the code for them is available in the example.
</p>
<pre>
instance Play Stm
instance Play Exp
instance Play Var

instance PlayEx Stm Stm
instance PlayEx Exp Exp
instance PlayEx Stm Exp
instance PlayEx Exp Stm
instance PlayEx Stm Var
instance PlayEx Exp Var
</pre>
<p>
    Of course, it is possible to write the Play instances using the PlayEx combinators (if we are willing to pay for undecidable instances), and for Exp this is shown:
</p>
<pre>
instance Play Exp where
    replaceChildren x =
        case x of
            EStm s -> playMore EStm s
            EAdd a b -> playTwo EAdd a b
            x -> playDefault x

instance PlayEx Exp Exp where; replaceChildrenEx = playSelf

instance Play a => PlayEx Exp a where
    replaceChildrenEx x =
        case x of
            EStm a -> play EStm /\ a
            EAdd a b -> play EAdd /\ a /\ b
            EVar a -> play EVar /\ a
            EInt a -> play EInt /\! a
</pre>
<p>
    These instances are more work than Compos, in particlar two copies have to be written compared to Compos, but they are at least relatively straight forward. If this is still too much work then:
</p>
<pre>
data Stm = ... deriving (Data,Typeable)
data Exr = ... deriving (Data,Typeable)
data Var = ... deriving (Data,Typeable)
</pre>
<p>
    This permits the use of the SYB definitions, at the cost of some type safety. No instances need to be written at all.
</p>
<p>
    While the choice of how to write the underlying functions is much more confusing with Play, compared to Compos, there is a good deal of flexibility. Depending on what features a user wishes to leverage, progressively shorter Play definitions can be specified. Hopefully the cost of writing instances will be low, compared to the use of Play functions. In one project the ratio is about 1:50, which supports this argument.
</p>

<h3>The <tt>rename</tt> function</h3>

<pre class="compos">
rename :: Tree c -> Tree c
rename t = case t of
    V x -> V ("_" ++ x)
    _   -> composOp rename t
</pre>
<pre>
rename :: PlayEx x Var => x -> x
rename = mapUnderEx $ \(V x) -> V ("_" ++ x)
</pre>
<p>
    The first thing to note is the Play function is shorter, there is only one constructor in type <tt>Var</tt>. In contrast Compos has merged all constructors into one GADT, and can not benefit from this. The Compos function works over all trees, including those based on <tt>Typ</tt>, which is meaningless, since types do not contain variables. The Play class only operates on <tt>Exp</tt> and <tt>Stm</tt> types.
</p>

<h3>The <tt>warnAssign</tt> function</h3>

<pre class="compos">
warnAssign :: Tree c -> IO ()
warnAssign t = case t of
    SAss _ _ -> putChar (chr 7)
    _ -> composM_ warnAssign t
</pre>
<pre>
warnAssign :: PlayEx x Stm => x -> IO ()
warnAssign = mapUnderExM_ $ \x -> case x of
	SAss _ _ -> putChar (chr 7)
	_ -> return ()
</pre>
<p>
    Here the traversals are very similar, both threading a Monad through the code. This example shows how monadic actions can be threading through a traversal, however, this is not usually necessary. Using the Play class, a more natural traversal emerges:
</p>
<pre>
warnAssign :: PlayEx x Stm => x -> IO ()
warnAssign x = putStr [chr 7 | SAss{} <- allOverEx x]
</pre>
<p>
    Here the Play class is very concise. The Play approach extracts the relevant bits with a list comprehension. Hopefully this shows how analysis functions can often be implemented with <tt>allOver</tt>, rathern than a traversal. The Compos version could be written using a fold, which would reduce it's complexity, although would still be more complex than the Compos version.
</p>


<h3>The <tt>symbols</tt> function</h3>

<pre class="compos">
symbols :: Tree c -> [(Tree Var, Tree Typ)]
symbols t = case t of
    SDecl typ var -> [(var,typ)]
    _ -> composOpMonoid symbols t
</pre>
<pre>
symbols :: PlayEx x Stm => x -> [(Var,Typ)]
symbols x = [(v,t) | SDecl t v <- allOverEx x]
</pre>
<p>
    Here the Compos function does a traversal of the tree, however again the Play class simply extracts the right bits. This example is almost identical to the previous <tt>warnAssign</tt> using Play, however the Compos approach introduces distinctions by requiring a more ordered approach to traversal.
</p>

<h3>The <tt>constFold</tt> function</h3>

<pre class="compos">
constFold :: Tree c -> Tree c
constFold e = case e of
    EAdd x y -> case (constFold x, constFold y) of
                    (EInt n, EInt m) -> EInt (n+m)
                    (x',y') -> EAdd x' y'
    _ -> composOp constFold e
</pre>
<pre>
constFold :: PlayEx x Exp => x -> x
constFold = mapUnderEx $ \e -> case e of
    EAdd (EInt n) (EInt m) -> EInt (n+m)
    x -> x
</pre>
<p>
    The constant folding operation is a bottom-up traversal, requiring sub expressions to have been replaced before they are examined. Unfortunately Compos only supports top-down traversals, requiring the user to manually do a small traversal in the middle. Play supports both types of traversals, and experience has shown that bottom-up is almost always what the user wants. This allows Play to produce shorter code.
</p>


<h3>Section 7.1.1</h3>

<p>
    The examples in Section 7.1.1 require lots of data types and lots of different styles of traversal. As such manual Play instances would not really be appropriate for this type of task - the instances would take too long to write. If we use the SYB instances, by importing <tt>Data.PlaySYB</tt> then we can start and take a look at the traversals. For this section, the SYB instance is presented first, followed by the Compos one, followed by the Play one.
</p>
<p>
    For completeness the data definition is reproduced here. For SYB and Play, deriving clauses have to be added. For Compos the whole thing is replaced by a GADT. All the code for Play is in the file <tt>Examples/SYB.hs</tt>.
</p>
<pre>
data Company = C [Dept]
data Dept = D Name Manager [Unit]
data Unit = PU Employee | DU Dept
data Employee = E Person Salary
data Person = P Name Address
data Salary = S Float
type Manager = Employee
type Name = String
type Address = String
</pre>

<h3>The <tt>increase</tt> function</h3>

<pre class="syb">
increase :: Data a => Float -> a -> a
increase k = everywhere (mkT (incS k))

incS :: Float -> Salary -> Salary
incS k (S s) = S (s * (1+k))
</pre>
<pre class="compos">
increase :: Float -> Tree c -> Tree c
increase k c = case c of
    S s -> S (s * (1+k))
    _ -> composOp (increase k) c
</pre>
<pre>
increase :: PlayEx x Salary => Float -> x -> x
increase k = mapUnderEx (\(S s) -> S (s * (1+k)))
</pre>
<p>
    Here the Play uses seems to be the most intuative. It requires no rank-2 types, no GADT's, and yet still provides the shortest code. The SYB approach requires separate functions to get the type classes working, and use of rather complex intermediates such as <tt>mkT</tt>. The Compos function is clearly much simpler, but by merging all the data constructors has to perform a case on the value. By keeping the original structure intact, Play can simply state the property.
</p>

<h3>The <tt>incrOne</tt> function</h3>

<pre class="syb">
incrOne :: Data a => Name -> Float -> a -> a
incrOne n k a | isDept n a = increase k a
              | otherwise = gmapT (incrOne n k) a

isDept :: Data a => Name -> a -> Bool
isDept n = False ‘mkQ‘ isDeptD n

isDeptD :: Name -> Dept -> Bool
isDeptD n (D n2 _ _) = n==n2
</pre>
<pre class="compos">
incrOne :: Name -> Float -> Tree c -> Tree c
incrOne d k c = case c of
    D n _ _ | n == d -> increase k c
    _ -> composOp (incrOne d k) c
</pre>
<pre>
incrOne :: PlayEx x Dept => String -> Float -> x -> x
incrOne name k = mapUnderEx (\d@(D n _ _) -> if name == n then increase k d else d)
</pre>
<p>
    Here SYB has grown substantially more complex, to accomodate the invariant. Compos still retains the same structure as before, and Play remains shorter - although the inherent complexity is the same as the Compos solution, in this instance.
</p>

<h3>The <tt>salaryBill</tt> function</h3>

<pre class="syb">
salaryBill :: Company -> Float
salaryBill = everything (+) (0 ‘mkQ‘ billS)

billS :: Salary -> Float
billS (S f) = f
</pre>
<pre class="compos">
salaryBill :: Tree c -> Float
salaryBill c = case c of
    S s -> s
    _ -> composOpFold 0 (+) salaryBill c
</pre>
<pre>
salaryBill :: PlayEx x Salary => x -> Float
salaryBill x = sum [x | S x <- allOverEx x]
</pre>
<p>
    Here the Play instance wins by being able to use a list comprehension to select the salary value out of a Salary object. The Play class is the only one that is able to use the standard Haskell <tt>sum</tt> function, not requiring an explicit fold to be performed. In this case it could easily be argued that <tt>billS</tt> is probably a general function, so the cost of writting it is not really correctly attributed to the SYB approach. If <tt>billS</tt> is a generally defined function, then you can rewrite the Play example as:
</p>
<pre>
salaryBill2 :: PlayEx x Salary => x -> Float
salaryBill2 = sum . map billS . allOverEx
</pre>
<p>
    This solution is nice in that it is a very specification orientated view of the problem. Take all the salaries, get their value, and sum them.
</p>


    </body>
</html>
